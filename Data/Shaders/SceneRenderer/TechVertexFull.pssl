ConstantBuffer uProjViewMtx
{
	row_major matrix projViewMatrix;
};

ConstantBuffer uModelMtx
{
	row_major matrix modelMatrix;
};

struct VS_INPUT
{
	float3 Position		: POSITION0;
	float2 UV			: TEXCOORD0;
	float3 Normal		: TEXCOORD1;
	float3 Tangent		: TEXCOORD2;
};


struct VS_OUTPUT
{
	float4 WorldPosition  : S_POSITION;
	float2 UV			: TEXCOORD0;
};
/*
// To implement
float3x3 inverse(float3x3 m)
{
	float det = determinant(m);
	float invDet = 1.0 / det;
	float3x3 minv;
	
	minv[0][0] = (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * invDet;
	minv[0][1] = (m[0][2] * m[2][1] - m[0][1] * m[2][2]) * invDet;
	minv[0][2] = (m[0][1] * m[1][2] - m[0][2] * m[1][1]) * invDet;
	minv[1][0] = (m[1][2] * m[2][0] - m[1][0] * m[2][2]) * invDet;
	minv[1][1] = (m[0][0] * m[2][2] - m[0][2] * m[2][0]) * invDet;
	minv[1][2] = (m[1][0] * m[0][2] - m[0][0] * m[1][2]) * invDet;
	minv[2][0] = (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * invDet;
	minv[2][1] = (m[2][0] * m[0][1] - m[0][0] * m[2][1]) * invDet;
	minv[2][2] = (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * invDet;

	return minv;
}
*/


VS_OUTPUT main(VS_INPUT input)
{
	VS_OUTPUT output;

  //  output.WorldPosition = mul(projViewMatrix, mul(modelMatrix,float4(input.Position, 1)));
	//output.WorldPosition = mul(mul(modelMatrix,projViewMatrix), float4(input.Position.xyz, 1));
	output.WorldPosition = mul(mul(projViewMatrix,modelMatrix), float4(input.Position.xyz, 1));
  // output.WorldPosition = mul(projViewMatrix,float4(input.Position, 1));
	output.UV = input.UV;
//	output.Normal = mul(transpose(inverse(float3x3(modelMatrix))),  normalize(input.Normal));

	
	return output;
}